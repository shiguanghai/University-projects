【第3版设计方案】这个方案中借助接口，将fly方法和quack从Duck类中剥离出来。
   这样子类Rubber和Wooden就没有覆盖（Override）父类的负担了。
   正是借助接口实现了多重继承，因为类是不可以多重继承。
   接口的本质也是一个类，一个特殊的类――里面只能包含静态常量和公有的抽象方法。
1.Duck里面仅仅保留所有子类都具备的方法
2.将子类可能具备或不具备的方法放到FlyBehavior接口和QuackBehavior接口中，这样就消除了Rubber和Wooden中定义空方法的负担。
3.每个子类根据自己的行为特征，有选择的实现不同的行为接口，并提供具体的实现方法。
4.虽然消除了Rubber和Wooden中的代码负担，但是却在Mallard和Redhead里引入的新的代码冗余。
【总结】第3版消除了第二版中的代码冗余，又在这版中对于Mallard和Redhead引入了新的代码冗余。
【提问】如果第2版抽象类的单继承和第3版接口的多继承方案，都无法彻底消除代码冗余，那么我们该怎么办？还有什么新的设计方案吗？
类之间有两种关系：1、继承（Inheritance），本质是一种is a的关系。2、组合（Composition），本质是一种has a的关系。

